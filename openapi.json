{"openapi": "3.0.2", "info": {"title": "exodus-gw", "description": "The exodus-gw service provides APIs for uploading and publishing content on the exodus CDN.\n\nAvailable APIs are grouped into the following categories:\n\n- [service](#tag/service): inspect the state of the exodus-gw service.\n- [upload](#tag/upload): upload blobs to the CDN without exposing them to end-users.\n  S3 compatible.\n- [publish](#tag/publish): atomically publish a set of blobs on the CDN under specified paths,\n  making them accessible to end-users.\n- [deploy](#tag/deploy): deploy configuration influencing the behavior of the CDN.\n- [cdn](#tag/cdn): utilities for accessing the CDN.\n\n## Overview of API usage\n\nA typical content publishing workflow using exodus-gw will consist of:\n\n- Use the upload APIs to ensure desired blobs are uploaded.\n   - As this API is partially S3-compatible, this can typically be done using\n     an existing S3 client library.\n- Use the publish API to create a publish object and create a (URI => blob)\n  mapping for the blobs you want to publish.\n- When you are ready to expose content to end-users, commit the publish object.\n  This will atomically unveil new content at all of the requested URIs.\n\n\n## Authentication\n\nThe exodus-gw API does not include any direct support for authentication and is\ninstead expected to be deployed behind a reverse-proxy implementing any desired\nauthentication mechanism.\n\nIf you are deploying an instance of exodus-gw, see\n[the deployment guide](https://release-engineering.github.io/exodus-gw/deployment.html)\nfor information on how to integrate an authentication mechanism.\n\nIf you are a client looking to make use of exodus-gw, consult your organization's\ninternal documentation for advice on how to authenticate with exodus-gw.\n\n\n## Environments\n\nMany APIs in exodus-gw use the concept of an \"environment\" to control the target system\nof an operation.\n\nThe set of environments is configured when exodus-gw is deployed. For example, separate\n\"production\" and \"staging\" environments may be configured, making use of separate storage\nbackends.\n\nDifferent environments will also require the user to hold different roles. For example,\na client might be permitted only to write to one of the configured environments, or all\nof them, depending on the configuration of the server.\n\nIf you are deploying an instance of exodus-gw, see\n[the deployment guide](https://release-engineering.github.io/exodus-gw/deployment.html)\nfor information on how to configure environments.\n\nIf you are a client looking to make use of exodus-gw, consult your organization's\ninternal documentation for advice on which environment(s) you should be using.\n", "version": "1.0.0"}, "paths": {"/healthcheck": {"get": {"tags": ["service"], "summary": "Healthcheck", "description": "Returns a successful response if the service is running.", "operationId": "healthcheck_healthcheck_get", "responses": {"200": {"description": "Service is up", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/MessageResponse"}}}}}}}, "/healthcheck-worker": {"get": {"tags": ["service"], "summary": "Healthcheck Worker", "description": "Returns a successful response if background workers are running.", "operationId": "healthcheck_worker_healthcheck_worker_get", "responses": {"200": {"description": "Worker(s) are responding", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/MessageResponse"}}}}}}}, "/whoami": {"get": {"tags": ["service"], "summary": "Whoami", "description": "Return basic information on the caller's authentication & authorization context.\n\nThis endpoint may be used to determine whether the caller is authenticated to\nthe exodus-gw service, and if so, which set of role(s) are held by the caller.\n\nIt is a read-only endpoint intended for diagnosing authentication issues.", "operationId": "whoami_whoami_get", "responses": {"200": {"description": "Caller's auth context retrieved", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/CallContext"}, "example": {"client": {"roles": ["someRole", "anotherRole"], "authenticated": true, "serviceAccountId": "clientappname"}, "user": {"roles": ["viewer"], "authenticated": true, "internalUsername": "someuser"}}}}}}}}, "/task/{task_id}": {"get": {"tags": ["service"], "summary": "Get Task", "description": "Return existing task object from database using given task ID.", "operationId": "get_task_task__task_id__get", "parameters": [{"description": "UUID of an existing task object.", "required": true, "schema": {"title": "task ID", "type": "string", "description": "UUID of an existing task object.", "format": "uuid"}, "name": "task_id", "in": "path"}], "responses": {"200": {"description": "Sucessfully retrieved task", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Task"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/upload/{env}/{key}": {"put": {"tags": ["upload"], "summary": "Upload bytes", "description": "Write to an object, either as a standalone operation or within a multi-part upload.\n\n**Required roles**: `{env}-blob-uploader`\n\nTo upload an entire object:\n- include all object bytes in request body\n- see also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html\n\nTo upload part of an object:\n- provide multipart upload ID in ``uploadId``\n- provide part number from 1 to 10,000 in ``partNumber``\n- include part of an object in request body (must be at least 5MB in size, except last part)\n- retain the `ETag` from the response, as it will be required to complete the upload\n- see also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html", "operationId": "upload_upload__env___key__put", "parameters": [{"description": "S3 object key", "required": true, "schema": {"title": "Key", "type": "string", "description": "S3 object key"}, "name": "key", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}, {"description": "ID of an existing multi-part upload.", "required": false, "schema": {"title": "Uploadid", "type": "string", "description": "ID of an existing multi-part upload."}, "name": "uploadId", "in": "query"}, {"description": "Part number, where multi-part upload is used.", "required": false, "schema": {"title": "Partnumber", "type": "integer", "description": "Part number, where multi-part upload is used."}, "name": "partNumber", "in": "query"}], "responses": {"200": {"description": "Successful Response"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "post": {"tags": ["upload"], "summary": "Create/complete multipart upload", "description": "Create or complete a multi-part upload.\n\n**Required roles**: `{env}-blob-uploader`\n\nTo create a multi-part upload:\n- include ``uploads`` in query string, with no value (e.g. ``POST /upload/{env}/{key}?uploads``)\n- see also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html\n\nTo complete a multi-part upload:\n- include ``uploadId`` in query string\n- include parts with ETags in request body\n- see also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_CompleteMultipartUpload.html", "operationId": "multipart_upload_upload__env___key__post", "parameters": [{"description": "S3 object key", "required": true, "schema": {"title": "Key", "type": "string", "description": "S3 object key"}, "name": "key", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}, {"description": "\nID of an existing multi-part upload.\n\nIf this argument is provided, it must be the ID of a multi-part upload\ncreated previously. The upload will be validated and completed.\n\nMust not be passed together with ``uploads``.", "required": false, "schema": {"title": "Uploadid", "type": "string", "description": "\nID of an existing multi-part upload.\n\nIf this argument is provided, it must be the ID of a multi-part upload\ncreated previously. The upload will be validated and completed.\n\nMust not be passed together with ``uploads``."}, "name": "uploadId", "in": "query"}, {"description": "\nIf this argument is provided, a new multi-part upload will be created\nand its ID returned. The provided value should be an empty string.\n\nMust not be passed together with ``uploadId``.", "required": false, "schema": {"title": "Uploads", "type": "string", "description": "\nIf this argument is provided, a new multi-part upload will be created\nand its ID returned. The provided value should be an empty string.\n\nMust not be passed together with ``uploadId``."}, "name": "uploads", "in": "query"}], "responses": {"200": {"description": "Successful Response"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "delete": {"tags": ["upload"], "summary": "Abort multipart upload", "description": "Abort a multipart upload.\n\n**Required roles**: `{env}-blob-uploader`\n\nIf an upload cannot be completed, explicitly aborting it is recommended in order\nto free up resources as early as possible, although this is not mandatory.\n\nSee also: https://docs.aws.amazon.com/AmazonS3/latest/API/API_AbortMultipartUpload.html", "operationId": "abort_multipart_upload_upload__env___key__delete", "parameters": [{"description": "S3 object key", "required": true, "schema": {"title": "Key", "type": "string", "description": "S3 object key"}, "name": "key", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}, {"description": "ID of a multipart upload", "required": true, "schema": {"title": "Uploadid", "type": "string", "description": "ID of a multipart upload"}, "name": "uploadId", "in": "query"}], "responses": {"200": {"description": "Empty response"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "head": {"tags": ["upload"], "summary": "Get object metadata", "description": "Retrieve metadata from an S3 object.\n\nNote that, as explained in [the upload API overview](#tag/upload), AWS-specific\nheaders such as `x-amz-*` are not included in the response.\nThe main purpose of this API is to determine whether or not an object\nidentified by checksum exists on the CDN.\n\n**Required roles**: `{env}-blob-uploader`", "operationId": "head_upload__env___key__head", "parameters": [{"description": "S3 object key", "required": true, "schema": {"title": "Key", "type": "string", "description": "S3 object key"}, "name": "key", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}], "responses": {"200": {"description": "Object exists"}, "404": {"description": "Object or environment does not exist"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/{env}/publish": {"post": {"tags": ["publish"], "summary": "Create new publish", "description": "Creates and returns a new publish object.\n\n**Required roles**: `{env}-publisher`", "operationId": "publish__env__publish_post", "parameters": [{"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}], "responses": {"200": {"description": "Publish created", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Publish"}, "example": {"id": "497f6eca-6276-4993-bfeb-53cbbbba6f08", "env": "prod", "links": {"self": "/prod/publish/497f6eca-6276-4993-bfeb-53cbbbba6f08", "commit": "/prod/publish/497f6eca-6276-4993-bfeb-53cbbbba6f08/commit"}, "items": []}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/{env}/publish/{publish_id}": {"get": {"tags": ["publish"], "summary": "Get Publish", "description": "Return existing publish object from database using given publish ID.\n\nBecause we don't have a use case for them and implementation would\nbe non-trivial, items belonging to the publish are not loaded/returned.\nThis is achieved using the noload() query option.", "operationId": "get_publish__env__publish__publish_id__get", "parameters": [{"description": "UUID of an existing publish object.", "required": true, "schema": {"title": "publish ID", "type": "string", "description": "UUID of an existing publish object.", "format": "uuid"}, "name": "publish_id", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}], "responses": {"200": {"description": "Publish found", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Publish"}, "example": {"id": "497f6eca-6276-4993-bfeb-53cbbbba6f08", "env": "live", "links": {"self": "/live/publish/497f6eca-6276-4993-bfeb-53cbbbba6f08", "commit": "/live/publish/497f6eca-6276-4993-bfeb-53cbbbba6f08/commit"}, "items": []}}}}, "404": {"description": "Publish not found", "content": "No publish found for ID 497f6eca-6276-4993-bfeb-53cbbbba6f08"}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "put": {"tags": ["publish"], "summary": "Update Publish Items", "description": "Add publish items to an existing publish object.\n\n**Required roles**: `{env}-publisher`\n\nPublish items primarily are a mapping between a URI relative to the root of the CDN,\nand the key of a binary object which should be exposed from that URI.\n\nAdding items to a publish does not immediately make them available from the CDN;\nthe publish object must first be committed.\n\nItems cannot be added to a publish once it has been committed.", "operationId": "update_publish_items__env__publish__publish_id__put", "parameters": [{"description": "UUID of an existing publish object.", "required": true, "schema": {"title": "publish ID", "type": "string", "description": "UUID of an existing publish object.", "format": "uuid"}, "name": "publish_id", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}], "requestBody": {"content": {"application/json": {"schema": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/ItemBase"}}, "example": [{"web_uri": "/my/awesome/file.iso", "object_key": "aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f", "content_type": "application/octet-stream"}, {"web_uri": "/my/slightly-less-awesome/other-file.iso", "object_key": "c06545d4e1a1c8e221d47e7d568c035fb32c6b6124881fd0bc17983bd9088ae0", "content_type": "application/octet-stream"}, {"web_uri": "/another/route/to/my/awesome/file.iso", "link_to": "/my/awesome/file.iso"}, {"web_uri": "/my/awesome/deletion.iso", "object_key": "absent"}]}}, "required": true}, "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EmptyResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/{env}/publish/{publish_id}/commit": {"post": {"tags": ["publish"], "summary": "Commit Publish", "description": "Commit an existing publish object.\n\n**Required roles**: `{env}-publisher`\n\nCommitting a publish has the following effects:\n\n- If enabled by server settings, static HTML indexes will be generated and added\n  onto the publish for certain content types such as yum repositories.\n- All URIs contained within the publish become accessible from the CDN,\n  pointing at their corresponding objects.\n  - This occurs with all-or-nothing semantics; see [Atomicity](#section/Atomicity).\n- The publish object becomes frozen - no further items can be added.\n\nCommit occurs asynchronously.  This API returns a Task object which may be used\nto monitor the progress of the commit.\n\nNote that exodus-gw does not resolve conflicts or ensure that any given path is\nonly modified by a single publish. If multiple publish objects covering the same\npath are being committed concurrently, URIs on the CDN may end up pointing to\nobjects from any of those publishes.", "operationId": "commit_publish__env__publish__publish_id__commit_post", "parameters": [{"description": "UUID of an existing publish object.", "required": true, "schema": {"title": "publish ID", "type": "string", "description": "UUID of an existing publish object.", "format": "uuid"}, "name": "publish_id", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}, {"required": false, "schema": {"title": "Deadline", "type": "string"}, "example": "2022-07-25T15:47:47Z", "name": "deadline", "in": "query"}], "responses": {"200": {"description": "Successful Response", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Task"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/{env}/deploy-config": {"post": {"tags": ["deploy"], "summary": "Deploy Config", "description": "Deploys CDN configuration data for use by Exodus components.\n\n**Required roles**: `{env}-config-deployer`\n\nDeployment occurs asynchronously. This API returns a Task object\nwhich may be used to monitor the progress of the deployment.", "operationId": "deploy_config__env__deploy_config_post", "parameters": [{"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}], "requestBody": {"description": "Configuration data for the CDN. Will replace the previously deployed configuration.", "content": {"application/json": {"schema": {"title": "Config", "required": ["listing", "origin_alias", "releasever_alias", "rhui_alias"], "type": "object", "properties": {"listing": {"type": "object", "additionalProperties": false, "description": "A mapping from paths to a yum variable name & list of values, used in generating 'listing' responses.", "patternProperties": {"^((?!/\\.+/)(/[\\w\\$\\.\\-]+))*$": {"type": "object", "properties": {"var": {"type": "string", "enum": ["releasever", "basearch"]}, "values": {"type": "array", "items": {"type": "string", "minLength": 1}, "uniqueItems": true}}}}}, "origin_alias": {"uniqueItems": true, "type": "array", "items": {"type": "object", "properties": {"src": {"pattern": "^((?!/\\.+/)(/[\\w\\$\\.\\-]+))*$", "type": "string", "description": "Path being aliased from, relative to CDN root."}, "dest": {"pattern": "^((?!/\\.+/)(/[\\w\\$\\.\\-]+))*$", "type": "string", "description": "Target of the alias, relative to CDN root."}}}, "description": "Aliases relating to /origin."}, "releasever_alias": {"uniqueItems": true, "type": "array", "items": {"type": "object", "properties": {"src": {"pattern": "^((?!/\\.+/)(/[\\w\\$\\.\\-]+))*$", "type": "string", "description": "Path being aliased from, relative to CDN root."}, "dest": {"pattern": "^((?!/\\.+/)(/[\\w\\$\\.\\-]+))*$", "type": "string", "description": "Target of the alias, relative to CDN root."}}}, "description": "Aliases relating to $releasever variables."}, "rhui_alias": {"uniqueItems": true, "type": "array", "items": {"type": "object", "properties": {"src": {"pattern": "^((?!/\\.+/)(/[\\w\\$\\.\\-]+))*$", "type": "string", "description": "Path being aliased from, relative to CDN root."}, "dest": {"pattern": "^((?!/\\.+/)(/[\\w\\$\\.\\-]+))*$", "type": "string", "description": "Target of the alias, relative to CDN root."}}}, "description": "Aliases relating to RHUI."}}, "additionalProperties": false}, "example": {"listing": {"/content/dist/rhel8": {"var": "releasever", "values": ["8", "8.0", "8.1", "8.2", "8.3", "8.4", "8.5"]}}, "origin_alias": [{"src": "/content/origin", "dest": "/origin"}, {"src": "/origin/rpm", "dest": "/origin/rpms"}], "releasever_alias": [{"dest": "/content/dist/rhel8/8.5", "src": "/content/dist/rhel8/8"}], "rhui_alias": [{"dest": "/content/dist/rhel8", "src": "/content/dist/rhel8/rhui"}]}}}, "required": true}, "responses": {"200": {"description": "Deployment enqueued", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/Task"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}, "/{env}/cdn/{url}": {"get": {"tags": ["cdn"], "summary": "Redirect (GET)", "description": "Redirects to a requested URL on the CDN.\n\nThe CDN requires a signature from an authorized signer in order to permit\nrequests. When using this endpoint, exodus-gw acts as an authorized signer\non the caller's behalf, thus allowing any exodus-gw client to access CDN\ncontent without holding the signing keys.\n\nThe URL used in the redirect will become invalid after a server-defined\ntimeout, typically less than one hour.", "operationId": "cdn_redirect__env__cdn__url__get", "parameters": [{"description": "URL of a piece of content relative to CDN root", "required": true, "schema": {"title": "URL", "type": "string", "description": "URL of a piece of content relative to CDN root"}, "example": "content/dist/rhel8/8/x86_64/baseos/os/repodata/repomd.xml", "name": "url", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}], "responses": {"302": {"description": "Redirect", "headers": {"location": {"description": "An absolute, signed, temporary URL of CDN content"}}, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EmptyResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}, "head": {"tags": ["cdn"], "summary": "Redirect (HEAD)", "description": "Identical to GET redirect, but for HEAD method.", "operationId": "cdn_redirect__env__cdn__url__head", "parameters": [{"description": "URL of a piece of content relative to CDN root", "required": true, "schema": {"title": "URL", "type": "string", "description": "URL of a piece of content relative to CDN root"}, "example": "content/dist/rhel8/8/x86_64/baseos/os/repodata/repomd.xml", "name": "url", "in": "path"}, {"description": "[Environment](#section/Environments) on which to operate.", "required": true, "schema": {"title": "environment", "type": "string", "description": "[Environment](#section/Environments) on which to operate."}, "name": "env", "in": "path"}], "responses": {"302": {"description": "Redirect", "headers": {"location": {"description": "An absolute, signed, temporary URL of CDN content"}}, "content": {"application/json": {"schema": {"$ref": "#/components/schemas/EmptyResponse"}}}}, "422": {"description": "Validation Error", "content": {"application/json": {"schema": {"$ref": "#/components/schemas/HTTPValidationError"}}}}}}}}, "components": {"schemas": {"CallContext": {"title": "CallContext", "type": "object", "properties": {"client": {"title": "Client", "allOf": [{"$ref": "#/components/schemas/ClientContext"}], "default": {"roles": [], "authenticated": false}}, "user": {"title": "User", "allOf": [{"$ref": "#/components/schemas/UserContext"}], "default": {"roles": [], "authenticated": false}}}, "description": "Represents an authenticated (or not) context for an incoming request.\n\nUse the fields on this model to decide whether the current request belongs\nto an authenticated user, and if so, to determine which role(s) are held\nby the user."}, "ClientContext": {"title": "ClientContext", "type": "object", "properties": {"roles": {"title": "Roles", "type": "array", "items": {"type": "string"}, "default": []}, "authenticated": {"title": "Authenticated", "type": "boolean", "default": false}, "serviceAccountId": {"title": "Serviceaccountid", "type": "string"}}, "description": "Call context data relating to service accounts / machine users."}, "EmptyResponse": {"title": "EmptyResponse", "type": "object", "properties": {}, "description": "An empty object."}, "HTTPValidationError": {"title": "HTTPValidationError", "type": "object", "properties": {"detail": {"title": "Detail", "type": "array", "items": {"$ref": "#/components/schemas/ValidationError"}}}}, "Item": {"title": "Item", "required": ["web_uri", "publish_id"], "type": "object", "properties": {"web_uri": {"title": "Web Uri", "type": "string", "description": "URI, relative to CDN root, which shall be used to expose this object."}, "object_key": {"title": "Object Key", "type": "string", "description": "Key of blob to be exposed; should be the SHA256 checksum of a previously uploaded piece of content, in lowercase hex-digest form. \n\nAlternatively, the string 'absent' to indicate that no content shall be exposed at the given URI. Publishing an item with key 'absent' can be used to effectively delete formerly published content from the point of view of a CDN consumer.", "default": ""}, "content_type": {"title": "Content Type", "type": "string", "description": "Content type of the content associated with this object.", "default": ""}, "link_to": {"title": "Link To", "type": "string", "description": "Path of file targeted by symlink.", "default": ""}, "publish_id": {"title": "Publish Id", "type": "string", "description": "Unique ID of publish object containing this item.", "format": "uuid"}}}, "ItemBase": {"title": "ItemBase", "required": ["web_uri"], "type": "object", "properties": {"web_uri": {"title": "Web Uri", "type": "string", "description": "URI, relative to CDN root, which shall be used to expose this object."}, "object_key": {"title": "Object Key", "type": "string", "description": "Key of blob to be exposed; should be the SHA256 checksum of a previously uploaded piece of content, in lowercase hex-digest form. \n\nAlternatively, the string 'absent' to indicate that no content shall be exposed at the given URI. Publishing an item with key 'absent' can be used to effectively delete formerly published content from the point of view of a CDN consumer.", "default": ""}, "content_type": {"title": "Content Type", "type": "string", "description": "Content type of the content associated with this object.", "default": ""}, "link_to": {"title": "Link To", "type": "string", "description": "Path of file targeted by symlink.", "default": ""}}}, "MessageResponse": {"title": "MessageResponse", "required": ["detail"], "type": "object", "properties": {"detail": {"title": "Detail", "type": "string", "description": "A human-readable message with additional info."}}}, "Publish": {"title": "Publish", "required": ["id", "env", "state"], "type": "object", "properties": {"id": {"title": "Id", "type": "string", "description": "Unique ID of publish object.", "format": "uuid"}, "env": {"title": "Env", "type": "string", "description": "Environment to which this publish belongs."}, "state": {"allOf": [{"$ref": "#/components/schemas/PublishStates"}], "description": "Current state of this publish."}, "updated": {"title": "Updated", "type": "string", "description": "DateTime of last update to this publish. None if never updated.", "format": "date-time"}, "links": {"title": "Links", "type": "object", "additionalProperties": {"type": "string"}, "description": "URL links related to this publish.", "default": {}}, "items": {"title": "Items", "type": "array", "items": {"$ref": "#/components/schemas/Item"}, "description": "All items (pieces of content) included in this publish.", "default": []}}}, "PublishStates": {"title": "PublishStates", "enum": ["PENDING", "COMMITTING", "COMMITTED", "FAILED"], "type": "string", "description": "An enumeration."}, "Task": {"title": "Task", "required": ["id", "publish_id", "state"], "type": "object", "properties": {"id": {"title": "Id", "type": "string", "description": "Unique ID of task object.", "format": "uuid"}, "publish_id": {"title": "Publish Id", "type": "string", "description": "Unique ID of publish object handled by this task.", "format": "uuid"}, "state": {"allOf": [{"$ref": "#/components/schemas/TaskStates"}], "description": "Current state of this task."}, "updated": {"title": "Updated", "type": "string", "description": "DateTime of last update to this task. None if never updated.", "format": "date-time"}, "deadline": {"title": "Deadline", "type": "string", "description": "DateTime at which this task should be abandoned.", "format": "date-time"}, "links": {"title": "Links", "type": "object", "additionalProperties": {"type": "string"}, "description": "URL links related to this task.", "default": {}}}}, "TaskStates": {"title": "TaskStates", "enum": ["NOT_STARTED", "IN_PROGRESS", "COMPLETE", "FAILED"], "type": "string", "description": "An enumeration."}, "UserContext": {"title": "UserContext", "type": "object", "properties": {"roles": {"title": "Roles", "type": "array", "items": {"type": "string"}, "default": []}, "authenticated": {"title": "Authenticated", "type": "boolean", "default": false}, "internalUsername": {"title": "Internalusername", "type": "string"}}, "description": "Call context data relating to human users."}, "ValidationError": {"title": "ValidationError", "required": ["loc", "msg", "type"], "type": "object", "properties": {"loc": {"title": "Location", "type": "array", "items": {"anyOf": [{"type": "string"}, {"type": "integer"}]}}, "msg": {"title": "Message", "type": "string"}, "type": {"title": "Error Type", "type": "string"}}}}}, "tags": [{"name": "service", "description": "APIs for inspecting the state of the exodus-gw service."}, {"name": "upload", "description": "An API for uploading binary data.\n\nThis API provides endpoints for uploading files into the data store\nused by the Exodus CDN. Uploading files does not immediately expose\nthem to clients of the CDN, but is a prerequisite of publishing files,\nwhich is achieved via the [publish](#tag/publish) APIs.\n\nThe upload API is a partially compatible subset of the S3 API.\nIt supports at least enough functionality such that the AWS SDK may be\nused when uploading to exodus-gw.\n\nDifferences from the AWS S3 API include:\n\n- Most optional arguments are not supported.\n\n- All `x-amz-*` headers, other than `x-amz-meta-*`, are omitted from responses.\n\n- The usual AWS authentication mechanism is unused; request signatures are ignored.\n  Authentication is expected to be performed by other means.\n\n- Object keys should always be SHA256 checksums of the objects being stored,\n  in lowercase hex digest form. This allows the object store to be used\n  as content-addressable storage.\n\n- When uploading content, the Content-MD5 and Content-Length headers are mandatory;\n  chunked encoding is not supported.\n\n- The API may enforce stricter limits or policies on uploads than those imposed\n  by the AWS API.\n\n## Using boto3 with the upload API\n\nAs the upload API is partially compatible with S3, it is possible to use\nexisting S3 clients such as the AWS SDK to perform uploads. This is the\nrecommended method of using the API. Here we show an example using boto, the\nAWS SDK for Python.\n\nUse `endpoint_url` when creating a boto resource or client to point at exodus-gw.\nRegion and credentials will be ignored.\n\nNote that, as the upload API provides only a subset of the S3 API, many boto methods\nwill not work. Uploading objects and querying the existence of an object are\nsupported.\n\n```python\nimport boto3\nfrom botocore.config import Config\n\n# Prepare S3 resource pointing at exodus-gw\ns3 = boto3.resource('s3',\n                    endpoint_url='https://exodus-gw.example.com/upload',\n                    # If SSL needs to be configured:\n                    verify='/path/to/bundle.pem',\n                    config=Config(client_cert=('client.crt', 'client.key')))\n\n# Bucket name must match one of the section names in exodus-gw.ini without 'env.' prefix\nbucket = s3.Bucket('dev')\n\n# Basic APIs such as upload_file now work as usual\nbucket.upload_file('/tmp/hello.txt',\n                   'aec070645fe53ee3b3763059376134f058cc337247c978add178b6ccdfb0019f')\n```\n"}, {"name": "publish", "description": "APIs for publishing blobs.\n\nIn the context of exodus-gw, \"publishing\" a blob means exposing it\nvia one or more user-accessible paths on the CDN. These blobs should first\nbe uploaded using the [upload](#tag/upload) APIs.\n\n\n## Atomicity\n\nexodus-gw aims to deliver atomic semantics for publishes; i.e., for a set\nof published content, committing the publish will make either *all* of it\navailable (if commit succeeds) or *none* of it available (if commit fails),\nwith no partial updates becoming visible from the point of view of a CDN\nclient.\n\nIn practice, limitations in the storage backend mean that true atomicity\nis not achieved for all but the smallest publishes, so it is more accurate\nto refer to the commit operation as \"near-atomic\".\n\nHere are a few of the strategies used by exodus-gw in order to achieve as\nclose as possible to atomic behavior:\n\n- exodus-gw performs writes to the underlying database (DynamoDB) in batches,\n  which themselves are committed atomically.\n\n  - (True atomicity could be achieved if the entire publish fits within\n     a single batch, but as batches have a maximum size of 25 items, this\n     is rarely the case.)\n\n- All operations are aggressively retried in case of error.\n\n- exodus-gw keeps track of what has been committed and is able to roll\n  back a partially committed publish in case of unrecoverable errors.\n\n- During commit, the items to be committed are prioritized intelligently\n  with knowledge of the types of content being published. Files which serve\n  as an index or entry point to a set of content are committed last, to ensure\n  minimal impact in the case that a commit is interrupted.\n\n  - Example: if a publish includes yum repositories, exodus-gw will ensure that\n    repomd.xml files are always committed last - ensuring there is no possibility\n    that an interrupted commit would unveil a repomd.xml file referencing other\n    files which were not yet committed.\n\nIt should be noted that the atomicity discussed here applies only to the interaction\nbetween exodus-gw and its underlying data store. exodus-gw does not contain any CDN\ncache purging logic; the impact of CDN caching must also be considered when evaluating\nthe semantics of a publish from the CDN client's point of view.\n\n\n## Expiry of publish objects\n\nPublish objects should be treated as ephemeral; they are not persisted indefinitely.\n\n- All publish objects which have reached a terminal state (failed or committed) will be\n  deleted after some server-defined timeout, defaulting to two weeks.\n- Publish objects which have been created but not committed within a server-defined timeout,\n  typically one day, will be marked as failed.\n\n\n## Expiry of task objects\n\nLike publish objects, task objects created when publishes are committed are not persisted\nindefinitely.\n\n- All task objects which have reached a terminal state (failed or complete) will be\n  deleted after some server-defined timeout, defaulting to two weeks.\n- Task objects not picked up by a worker within a server-defined time limit, defaulting\n  to two hours, will be marked as failed along with the associated publish object. This\n  prevents system overload in the event of a worker outage.\n"}, {"name": "deploy", "description": "APIs for adjusting configuration used by the CDN."}, {"name": "cdn", "description": "Utilities for accessing the Exodus CDN."}]}